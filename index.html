<!doctype html>
<html lang="en">
<head>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap" rel="stylesheet">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>DotFather</title>
<style>
  /* Custom Godfather font import */
  @font-face {
    font-family: 'TheGodfather';
    src: url('./fonts/the-godfather.regular.ttf') format('truetype');
    font-weight: normal;
    font-style: normal;
    font-display: swap; /* Helps with font loading */
  }
  
  /* Ensure custom font is used for title */
  .godfather-title {
    font-family: 'TheGodfather', 'Courier New', monospace !important;
  }
  
  :root { --stroke: 2; --period: 60; } /* seconds per rotation */
  html,body { height:100%; margin:0; background:#fff; }
  svg {
  width: 130%;
  height: 130%;
  position: absolute;
  left: 50%; top: 50%;
  transform: translate(-50%,-50%);
}

  .boundary {
  fill: none;
  stroke: #000;
  stroke-width: var(--stroke);
  vector-effect: non-scaling-stroke;
  stroke-linecap: square;     /* helps visually “kiss” the corners */
  shape-rendering: crispEdges; /* reduces anti-aliasing fuzz */
}

  .filled { fill:#000; stroke:none; }
  .white-filled { fill:#fff; stroke:none; }

  .circle { fill:#fff; pointer-events:none; transition: fill 0.2s; }
  .rect   { fill:#000; pointer-events:none; transition: fill 0.2s; }

  /* Flash effects */
  .circle.flash { fill:#888 !important; }
  .rect.flash   { fill:#666 !important; }


  text { font-family:sans-serif; font-size:5px; }
  .text-white { fill:#fff; }
  
  /* Auto-inverting text based on background */
  .adaptive-text {
    font-family: "EB Garamond", serif;
    fill: #fff;
    mix-blend-mode: difference;
  }
  
  /* Small text size class */
  .small-text {
    font-size: 3px !important;
    transition: opacity 0.3s ease-in-out;
  }

</style>
</head>
<body>
<svg viewBox="0 0 100 100" preserveAspectRatio="xMidYMid slice">
  <defs>
    <clipPath id="clip" clipPathUnits="userSpaceOnUse">
      <rect x="0" y="0" width="100" height="100"/>
    </clipPath>
    
    <!-- Mask for detecting overlap with black areas -->
    <mask id="textMask">
      <rect width="100" height="100" fill="white"/>
      <!-- Black areas will make text invisible, white areas visible -->
      <use href="#rotor" fill="black"/>
    </mask>
  </defs>

  <!-- Rotating group -->
  <g id="rotor">
    <!-- White filled side (lower portion) -->
    <polygon class="white-filled"
      points="-1000000,35  50,38  50,62  1000000,65
              1000000,100  -1000000,100" />

    <!-- Black filled side (upper portion) -->
    <polygon class="filled"
      points="-1000000,35  50,38  50,62  1000000,65
              1000000,0    -1000000,0" />

    <!-- Boundary line -->
    <polyline class="boundary"
      points="-1000000,35  50,38  50,62  1000000,65" />

    <!-- White circle (on diagonal axis, upper-right) -->
    <circle id="circle" class="circle" r="5"/>

    <!-- Black rectangle (on diagonal axis, lower-left, long side parallel to vertical edge) -->
    <rect id="rect" class="rect" width="4" height="13"/>
  </g>

  <!-- Top-right title (after rotating group so it renders on top) -->
  <!-- Dingding icon beside "The" text -->
  <image x="80" y="29.5" width="6" height="8" href="./dingding.svg" opacity="0.8"/>
  
  <text x="79" y="32"
        font-family="TheGodfather, Courier New, monospace"
        font-size="4"
        font-weight="500"
        fill="#ffffff"
        class="adaptive-text godfather-title"
        text-anchor="end"
        dominant-baseline="hanging">The </text>
  
  <text x="84.5" y="36"
        font-family="TheGodfather, Courier New, monospace"
        font-size="4"
        font-weight="500"
        fill="#ffffff"
        class="adaptive-text godfather-title"
        text-anchor="end"
        dominant-baseline="hanging">
Dotfather  </text>
        

<text x="47" y="65"
        font-family="Courier New, monospace"
        font-weight="700"
        fill="#ffffff"
        class="adaptive-text small-text"
        text-anchor="end"
        dominant-baseline="hanging">
Click anywhere to continue  </text>

</svg>



<script>
  // Ensure custom font is loaded
  document.fonts.ready.then(function() {
    console.log('All fonts loaded');
    // Force redraw of text elements with custom font
    const titleElements = document.querySelectorAll('.godfather-title');
    titleElements.forEach(el => {
      el.style.fontFamily = "'TheGodfather', 'Courier New', monospace";
    });
  });

  const circle = document.getElementById('circle');
  const rect   = document.getElementById('rect');

  const d = 10; // offset from center along diagonal

  // Circle on axis: top-right
  circle.setAttribute('cx', 50 + d);
  circle.setAttribute('cy', 60 - d);

  // Rectangle on axis: bottom-left
  const rw = 0, rh = 32; // vertical long side
  const rx = 50 - d, ry = 50 + d;
  rect.setAttribute('x', rx - rw/2);
  rect.setAttribute('y', ry - rh/2);

  // Rotation animation
  const rotor = document.getElementById('rotor');
  const hash = new URLSearchParams(location.hash.slice(1));
  const periodSec = Number(hash.get('period')) || 60;
  const period = periodSec * 1000;

  if (!matchMedia('(prefers-reduced-motion: reduce)').matches) {
    let t0 = performance.now();
    (function animate(now){
      const t = ((now - t0) % period) / period;
      rotor.setAttribute('transform', `rotate(${t * 360} 50 50)`);
      
      // Optional: Check for overlaps and change text color
      // checkTextOverlap(t);
      
      requestAnimationFrame(animate);
    })(t0);
  }

  // Alternative approach: JavaScript-based overlap detection
  function checkTextOverlap(rotationProgress) {
    const textElement = document.querySelector('.adaptive-text');
    const polygon = document.querySelector('.filled');
    
    // Get text bounding box (approximate)
    const textX = 60, textY = 40;
    const textWidth = 15, textHeight = 4; // approximate text dimensions
    
    // Calculate if the rotating black polygon overlaps with text area
    const angle = rotationProgress * 360;
    
    // Simplified check: if rotation brings black area near text position
    // This is a basic example - you'd want more precise collision detection
    const isOverBlackArea = (angle > 315 || angle < 45) && textY < 50;
    
    if (isOverBlackArea) {
      textElement.setAttribute('fill', '#ffffff'); // white on black
    } else {
      textElement.setAttribute('fill', '#000000'); // black on white
    }
  }

  // ------- Input -> DOT (short press only) -> Redirect -------
  let pressStart = null;
  let navigating = false; // prevent double fires
  let feedbackTimeouts = []; // track active timeouts

  const THRESHOLD = 250;           // < 250ms = dot, >= 250ms = ignored
  const DOT_URL   = 'dot.html';

  function clearFeedbackTimeouts() {
    feedbackTimeouts.forEach(timeout => clearTimeout(timeout));
    feedbackTimeouts = [];
  }

  function handleSignal(duration){
    if (navigating) return;
    if (duration < THRESHOLD) {
      // Short press - redirect to dot.html
      circle.classList.add('flash');
      setTimeout(()=>circle.classList.remove('flash'), 200);
      navigating = true;
      setTimeout(()=>location.href = DOT_URL, 500); // tiny delay for feedback
    } else {
      // Long press - prompt user to click instead of hold
      const instructionText = document.querySelector('.small-text');
      const originalText = 'Click anywhere to continue'; // fixed original text
      
      // Clear any existing feedback timeouts
      clearFeedbackTimeouts();
      
      // Fade out
      instructionText.style.opacity = '0';
      
      // Change text after fade out completes
      const timeout1 = setTimeout(() => {
        instructionText.textContent = 'Quick tap, don\'t hold!';
        // Fade back in
        instructionText.style.opacity = '1';
      }, 300);
      feedbackTimeouts.push(timeout1);
      
      // Reset text after 2 seconds with fade transition
      const timeout2 = setTimeout(() => {
        instructionText.style.opacity = '0';
        const timeout3 = setTimeout(() => {
          instructionText.textContent = originalText;
          instructionText.style.opacity = '1';
        }, 300);
        feedbackTimeouts.push(timeout3);
      }, 2000);
      feedbackTimeouts.push(timeout2);
    }
  }

  // Keyboard (Enter)
  window.addEventListener('keydown', e => {
    if (e.code === 'Enter' && pressStart === null) {
      pressStart = Date.now();
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', e => {
    if (e.code === 'Enter' && pressStart !== null) {
      const duration = Date.now() - pressStart; 
      pressStart = null;
      handleSignal(duration); 
      e.preventDefault();
    }
  });

  // Mouse (left button)
  window.addEventListener('mousedown', e => {
    if (e.button === 0 && pressStart === null) {
      pressStart = Date.now();
    }
  });
  window.addEventListener('mouseup', e => {
    if (e.button === 0 && pressStart !== null) {
      const duration = Date.now() - pressStart; 
      pressStart = null;
      handleSignal(duration);
    }
  });

  // Touch (mobile)
  window.addEventListener('touchstart', e => {
    if (pressStart === null) {
      pressStart = Date.now();
    }
  }, {passive:true});
  window.addEventListener('touchend', e => {
    if (pressStart !== null) {
      const duration = Date.now() - pressStart; 
      pressStart = null;
      handleSignal(duration);
    }
  });
</script>

</body>
</html>