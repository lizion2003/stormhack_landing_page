<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Duel Dot Dash</title>
<style>
  :root { --stroke: 2; --period: 60; } /* seconds per rotation */
  html,body { height:100%; margin:0; background:#fff; }
  svg {
  width: 130%;
  height: 130%;
  position: absolute;
  left: 50%; top: 50%;
  transform: translate(-50%,-50%);
}

  .boundary {
  fill: none;
  stroke: #000;
  stroke-width: var(--stroke);
  vector-effect: non-scaling-stroke;
  stroke-linecap: square;     /* helps visually “kiss” the corners */
  shape-rendering: crispEdges; /* reduces anti-aliasing fuzz */
}

  .filled { fill:#000; stroke:none; }
  .white-filled { fill:#fff; stroke:none; }

  .circle { fill:#fff; pointer-events:none; transition: fill 0.2s; }
  .rect   { fill:#000; pointer-events:none; transition: fill 0.2s; }

  /* Flash effects */
  .circle.flash { fill:#888 !important; }
  .rect.flash   { fill:#666 !important; }


  text { font-family:sans-serif; font-size:5px; }
  .text-white { fill:#fff; }
  
  /* Auto-inverting text based on background */
  .adaptive-text {
    fill: #fff;
    mix-blend-mode: difference;
  }

   /* Hint text, subtle in bottom-right */
  .hint {
    position: absolute;
    bottom: 12px;
    right: 16px;
    font-family: sans-serif;
    font-size: 13px;
    color: #777;
    background: rgba(255,255,255,0.6);
    padding: 4px 8px;
    border-radius: 4px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    user-select: none;
    pointer-events: none;
  }

</style>
</head>
<body>
<svg viewBox="0 0 100 100" preserveAspectRatio="xMidYMid slice">
  <defs>
    <clipPath id="clip" clipPathUnits="userSpaceOnUse">
      <rect x="0" y="0" width="100" height="100"/>
    </clipPath>
    
    <!-- Mask for detecting overlap with black areas -->
    <mask id="textMask">
      <rect width="100" height="100" fill="white"/>
      <!-- Black areas will make text invisible, white areas visible -->
      <use href="#rotor" fill="black"/>
    </mask>
  </defs>

  <!-- Rotating group -->
  <g id="rotor">
    <!-- White filled side (lower portion) -->
    <polygon class="white-filled"
      points="-1000000,40  50,42  50,58  1000000,60
              1000000,100  -1000000,100" />

    <!-- Black filled side (upper portion) -->
    <polygon class="filled"
      points="-1000000,40  50,42  50,58  1000000,60
              1000000,0    -1000000,0" />

    <!-- Boundary line -->
    <polyline class="boundary"
      points="-1000000,40  50,42  50,58  1000000,60" />

    <!-- White circle (on diagonal axis, upper-right) -->
    <circle id="circle" class="circle" r="3"/>

    <!-- Black rectangle (on diagonal axis, lower-left, long side parallel to vertical edge) -->
    <rect id="rect" class="rect" width="3" height="9"/>
  </g>

  <!-- Top-right title (after rotating group so it renders on top) -->
  <text x="82" y="32"
        font-family="Courier New, monospace"
        font-size="4"
        font-weight="700"
        fill="#ffffff"
        class="adaptive-text"
        text-anchor="end"
        dominant-baseline="hanging">
    BONK!
  </text>

</svg>



<div class="hint">
  Press <strong>(Enter)</strong>: tap for DOT ·, hold for DASH –
</div>

<script>
  const circle = document.getElementById('circle');
  const rect   = document.getElementById('rect');

  const d = 10; // offset from center along diagonal

  // Circle on axis: top-right
  circle.setAttribute('cx', 47 + d);
  circle.setAttribute('cy', 60 - d);

  // Rectangle on axis: bottom-left
  const rw = -3, rh = 28; // vertical long side
  const rx = 50 - d, ry = 50 + d;
  rect.setAttribute('x', rx - rw/2);
  rect.setAttribute('y', ry - rh/2);

  // Rotation animation
  const rotor = document.getElementById('rotor');
  const hash = new URLSearchParams(location.hash.slice(1));
  const periodSec = Number(hash.get('period')) || 60;
  const period = periodSec * 1000;

  if (!matchMedia('(prefers-reduced-motion: reduce)').matches) {
    let t0 = performance.now();
    (function animate(now){
      const t = ((now - t0) % period) / period;
      rotor.setAttribute('transform', `rotate(${t * 360} 50 50)`);
      
      // Optional: Check for overlaps and change text color
      // checkTextOverlap(t);
      
      requestAnimationFrame(animate);
    })(t0);
  }

  // Alternative approach: JavaScript-based overlap detection
  function checkTextOverlap(rotationProgress) {
    const textElement = document.querySelector('.adaptive-text');
    const polygon = document.querySelector('.filled');
    
    // Get text bounding box (approximate)
    const textX = 60, textY = 40;
    const textWidth = 15, textHeight = 4; // approximate text dimensions
    
    // Calculate if the rotating black polygon overlaps with text area
    const angle = rotationProgress * 360;
    
    // Simplified check: if rotation brings black area near text position
    // This is a basic example - you'd want more precise collision detection
    const isOverBlackArea = (angle > 315 || angle < 45) && textY < 50;
    
    if (isOverBlackArea) {
      textElement.setAttribute('fill', '#ffffff'); // white on black
    } else {
      textElement.setAttribute('fill', '#000000'); // black on white
    }
  }

  // ------- Input -> DOT/DASH -> Redirect -------
  let pressStart = null;
  let navigating = false; // prevent double fires

  const THRESHOLD = 250;           // < 250ms = dot, >= 250ms = dash
  const DOT_URL   = 'duel.html';
  const DASH_URL  = 'learn.html';

  function handleSignal(duration){
    if (navigating) return;
    if (duration < THRESHOLD) {
      circle.classList.add('flash');
      setTimeout(()=>circle.classList.remove('flash'), 200);
      navigating = true;
      setTimeout(()=>location.href = DOT_URL, 500); // tiny delay for feedback
    } else {
      rect.classList.add('flash');
      setTimeout(()=>rect.classList.remove('flash'), Math.min(duration, 400));
      navigating = true;
      setTimeout(()=>location.href = DASH_URL, 500);
    }
  }

  // Keyboard (Enter)
  window.addEventListener('keydown', e => {
    if (e.code === 'Enter' && pressStart === null) {
      pressStart = Date.now();
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', e => {
    if (e.code === 'Enter' && pressStart !== null) {
      const duration = Date.now() - pressStart; pressStart = null;
      handleSignal(duration); e.preventDefault();
    }
  });

  // Mouse (left)
  window.addEventListener('mousedown', e => {
    if (e.button === 0 && pressStart === null) pressStart = Date.now();
  });
  window.addEventListener('mouseup', e => {
    if (e.button === 0 && pressStart !== null) {
      const duration = Date.now() - pressStart; pressStart = null;
      handleSignal(duration);
    }
  });

  // Touch (mobile) — use passive:false so we can prevent scroll if needed
  window.addEventListener('touchstart', e => {
    if (pressStart === null) pressStart = Date.now();
  }, {passive:true});
  window.addEventListener('touchend', e => {
    if (pressStart !== null) {
      const duration = Date.now() - pressStart; pressStart = null;
      handleSignal(duration);
    }
  });
</script>

</body>
</html>