<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Compact Z Boundary (short vertical)</title>
<style>
  :root { --stroke: 3; --period: 60; } /* seconds per rotation */
  html,body { height:100%; margin:0; background:#fff; }
  svg { width:100vw; height:100vh; display:block; }
  .boundary {
    fill:none;
    stroke:#000;
    stroke-width:var(--stroke);
    vector-effect:non-scaling-stroke;
    stroke-linejoin:miter;
    stroke-linecap:butt;
  }
</style>
</head>
<body>
  <svg viewBox="0 0 100 100" preserveAspectRatio="xMidYMid slice">
    <defs>
      <clipPath id="clip" clipPathUnits="userSpaceOnUse">
        <rect x="0" y="0" width="100" height="100" />
      </clipPath>
    </defs>

    <g id="rotor" clip-path="url(#clip)">
      <!-- Z-shaped boundary centered on the rotation origin (50,50).
           End segments use a very large half-length so the rotated line
           always reaches the viewport corners. Adjust L if needed. -->
      <g transform="translate(50 50)">
        <!-- points: (-L, -10)  (0, 8)  (0, -8)  (L, 10) -->
        <polyline class="boundary"
          points="-1000,-10 0,8 0,-8 1000,10" />
      </g>
    </g>
  </svg>

  <script>
    const rotor = document.getElementById('rotor');
    const hash = new URLSearchParams(location.hash.slice(1));
    const periodSec = Number(hash.get('period')) || 60; // default 60s
    const period = periodSec * 1000;

    if (!matchMedia('(prefers-reduced-motion: reduce)').matches) {
      let t0 = performance.now();
      (function animate(now){
        const t = ((now - t0) % period) / period;
        rotor.setAttribute('transform', `rotate(${t * 360} 50 50)`);
        requestAnimationFrame(animate);
      })(t0);
    }
  </script>
</body>
</html>
